#include <string>
#include <iostream>
using namespace std;
class MyClass
{
    int size;
public:
    int* data;

    MyClass(int size)
    {
        this->size = size;
        this->data = new int[size];
        for (int i = 0; i < size; i++)
        {
            data[i] = i;
        }
        cout << "Вызволся конструктор " << this << endl;
    }

    MyClass(const MyClass& other)
    {
        this->size = other.size;
        this->data = new int[other.size];

        for (int i = 0; i < other.size; i++)
        {
            this->data[i] = other.data[i];
        }
    }
    // const MyClass& other это константная ссылка на объект класса
    //ссылка потому что нам не нужна копия объекта а толко нужно посмотреть что там лежит
    //константная она потому что мы там ничего менять не собираемся и для того чтобы себя обезопасить чтобы ничего случайнео не изменить пишем const
    //после перегрузки у обьекта класса появляется функция operator=
    //компилятор позволяет не писать: a.operator=(b) а позволяет просто написать вот так: a = b

    void operator = (const MyClass& other)
    {
        cout << "Вызволся оператора присваивания  = " << this << endl;
    }

    ~MyClass()
    {
        cout << "Вызволся деструктор " << this << endl;
        delete[]data;
    }
};
int main()
{
    MyClass a(10);
    MyClass b(2);

    a = b;
    //если мы хотим сразу при создании объекта b 
    //присвоить ему значение a , то в таком случае
    //так как обьект b еще не был инициализирован вообще ничем
    //и мы фактически еще должны его создать так как его еще нету
    //то здесь компилятор вызовет конструктор копирования
    //по сути если мы еще объект не создали и хотим присвоить ему значение
    //то запись MyClass b=a; эквивалентна записи  MyClass b(a);
    //как будто мы просто бы вызывали конструктор копирования
    
    /*MyClass b(a);

    //если не делать перегрузку оператора присваивания "=" 
    //то просто будет 2 переменные a и b ссылающиеся на одну и ту же область памяти 
    a = b;*/
}

